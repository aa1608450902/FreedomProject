2018-05-16
寄存器
以下称呼其实都是给CPU内部某些部件取的一个名称，或标示符。
8位寄存器    16位寄存器
AH AL       AX  - 又称：类加器
BH BL       BX  - Base address register
CH CL       CX  - count 计数器
DH DL       DX  - Data 数据寄存器

32位寄存器
EAX  - 通用寄存器
EBX
ECX
EDX

其他 特殊功能寄存器
CS IP
SS SP
DI SI BP
......

16位CPU
32位CPU
    - 实模式    内存单元的逻辑地址：段值：偏移量
    - 保护模式  装入段寄存器的不再是段值，而是称为”选择子”(Selector)的某个值。
16位实模式
32位保护模式

CPU内部的段寄存器：
CS——代码段寄存器(Code Segment Register)，其值为代码段的段值；
DS——数据段寄存器(Data Segment Register)，其值为数据段的段值；
ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；
SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；
FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；
GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。

每个进程拥有4G的线性内存空间

内存管理 - 虚拟内存机制
(分别什么地方用的？)
虚拟地址  ->  物理地址
转换？：通过页表(？是怎样实现的？在内存中？还是寄存器中？怎样存储的？)

[虚拟内存机制](https://blog.csdn.net/zhyfxy/article/details/70157248)
[页式存储机制](https://blog.csdn.net/newcong0123/article/details/52792070)
[内存地址转换与分段](https://www.cnblogs.com/mfrbuaa/p/5378147.html)
页式存储机制
页表的存储结构：
一个页表4K(32bit)
第0个物理页从物理地址 0x00000000 处开始。由于页的大小为4KB，就是0x1000字节，所以第1页从物理地址0x00001000 处开始。第2页从物理地址 0x00002000 处开始。

页表：一个页表的大小为4K字节(32bit)，放在一个物理页中。由1024个4字节的页表项组成。
页表中的每一项的内容（每项4个字节,32bit）高20bit用来放一个物理页的物理地址，低12bit放着一些标志。

页目录：一个页目录大小为4K字节(32bit)，放在一个物理页中。由1024个4字节的页目录项组成。
页目录中的每一项的内容（每项4个字节）高20bit用来放一个页表的物理地址，低12bit放着一些标志。


感悟：硬件和系统软件是相辅相成的。软件不够用，硬件来凑。
虽说操作系统是基于硬件的设计的，但是硬件也是基于软件思想的。
弄清硬件系统提供的机制，再去理解操作系统软件的执行/操作流程。
硬件机制：
    提供的gdtr/ldtr寄存器来存储页表项即页表的物理地址
那软件怎样才能实现页表机制？



指令：mov eax,004227b8h
如果CPU寄存器中的分页标志位被设置，那么执行内存操作的机器指令时，CPU会自动根据页目录和页表中的信息，把虚拟地址转换成物理地址，完成该指令。比如 mov eax,004227b8h ，这是把地址004227b8h处的值赋给寄存器的汇编代码，004227b8这个地址就是虚拟址。CPU在执行这行代码时，发现寄存器中的分页标志位已经被设定，就自动完成虚拟地址到物理地址的转换，使用物理地址取出值，完成指令。对于Intel CPU 来说，分页标志位是寄存器CR0的第31位，为1表示使用分页，为0表示不使用分页。对于初始化之后的 Win2k 我们观察 CR0 ，发现第31位为1。表明Win2k是使用分页的。

寄存器运算时溢出，CPU是怎么处理的？

































2018-05-15
我现在重新加深对linux kernel的理解是为了做什么？
答: 2018-05-15 
    1. 为了熟练地，充分的利用linux操作系统提供的功能。充分利用好linux操作系统的工具
    2. 熟练地 去进行 系统调用，熟练地 系统编程

several important Questions:

1. 进程是怎样转移控制权的？

2. 保护模式下，内存互不干扰是怎样实现的？
    多任务 + 虚拟内存技术的实现(段地址 + 偏移地址)

#. 计算机内部寄存器可视化

3. linux内核的main起点？
答: linux kernel的c程序由汇编直接调用，汇编级别不存在main函数起点。
早期Linux内核引导代码只有bootsect.s、setup.s、head.s这3个文件，由Linus亲手写的。

#. 将c语言汇编成汇编代码，查看汇编代码结构。
c语言编译成汇编后，程序也会被分成 1. 数据段 2. 代码段 3. 

4. CPU的多核是怎样被使用的，汇编只利用了单个CPU，怎样操作多个CPU的？

linux kernel constitution:
1. system call
2. 中断

linux kernel's several classic Questions:

1. linux系统的启动过程

2. system_call的过程